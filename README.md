## üöÄ Documentacion de ingenieria - Innova Tech

Este repositorio contiene todos los materiales necesarios para crear a "Ledma Tech_MK1", el robot aut√≥nomo creado por el equipo "Innova Tech", que participar√° en la categor√≠a Futuros ingeniero en la Clasificaion de la World Robot Olympiad en la temporada 2025.

##  Contenido 

- Miembros del equipo 
- introduccion 
- dise√±o adaptado 
-  Materiales y Componentes


## üìñ Introducci√≥n
En este repositorio se observar√° un arduo proceso tanto de selecci√≥n, as√≠ como de armado del carrito RC, para la categor√≠a Futuros Ingenieros de la WRO. Fue un proceso realizado con gran esfuerzo, independientemente de las dificultades. Un trabajo en equipo y dedicaci√≥n para dar lo mejor de nosotros en la demostraci√≥n a los jueces, conociendo las bases de la rob√≥tica y aprendiendo mucho en el proceso nos basamos en mec√°nica, electr√≥nica y programaci√≥n, pensando siempre en aprender m√°s para presentar as√≠ un proyecto capaz de desempe√±ar √≥ptimamente y aut√≥nomamente todos los objetivos.





## Miembros del equipo 
-Leontino Jose Medina Di Donato

-Adriana Carolina Palmar Molero

-Dharma Alexandra Pe√±a Jim√©nez

Somos jovenes estudiantes de ingenier√≠a, donde nos conocimos en las aulas de la institucion como futuros ingenieros, al comienzo de la carrera y decidimos participar en la competencia por la pasi√≥n que compartimos de armar proyectos. La competencia nos llamo la atencion para poder expandir nuestros conocimientos de rob√≥tica, y explotar nuestras capacidades como un equipo de jovenes que buscan mirar m√°s all√° de sus fronteras. 

![WhatsApp Image 2025-06-07 at 17 47 40](https://github.com/user-attachments/assets/3568e8a1-b1b9-4abf-abde-68d06ec69484)


**Chasis de referencias de modelado 3D**

Al comienzo de nuestra inmersi√≥n para esta competencia, decidimos explotar al m√°ximo todos los recursos disponibles a nuestra disposici√≥n, entre ellos los muchos modelos que hay en internet de modelado 3D para chasis, entre ellos encontramos uno que nos funcionaba en muchos factores, ya sea tiempo, factibilidad, est√©tica, etc. Aqu√≠ dejamos el link a disposicion para mas informaci√≥n adem√°s de adjuntar la imagen de referencia y las im√°genes de nuestro chasis post impresi√≥n 3D.




 https://cults3d.com/es/modelo-3d/juegos/casis-1-10-adaptable

![Chasis-RC-02](https://github.com/user-attachments/assets/9e7c69a4-fcab-4fcb-8af9-bcbd09175e0b)

### **Chasis Armado**

[![](https://private-user-images.githubusercontent.com/147768482/452440916-3ea8a2ea-8c3c-4cf5-b728-1cdf928101bc.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTE2LTNlYThhMmVhLThjM2MtNGNmNS1iNzI4LTFjZGY5MjgxMDFiYy5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1hYWU5ZjdkZWI2OTg3MGQ3ZDA1YWY3M2M0NGQxZTM2NGY3ZWYzNDdhMmQ3MDA0YmI4ZmI1MTAwMWQzM2Q5ZjIxJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.gCb0gfFzAoQ2r3PP932QrQqkEkITuoaZtzW44D_CnMI)](http://https://private-user-images.githubusercontent.com/147768482/452440916-3ea8a2ea-8c3c-4cf5-b728-1cdf928101bc.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTE2LTNlYThhMmVhLThjM2MtNGNmNS1iNzI4LTFjZGY5MjgxMDFiYy5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1hYWU5ZjdkZWI2OTg3MGQ3ZDA1YWY3M2M0NGQxZTM2NGY3ZWYzNDdhMmQ3MDA0YmI4ZmI1MTAwMWQzM2Q5ZjIxJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.gCb0gfFzAoQ2r3PP932QrQqkEkITuoaZtzW44D_CnMI)

[![chasis ](https://private-user-images.githubusercontent.com/147768482/452440924-43a830bd-0473-43b1-a4c9-bbeb139ec016.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTI0LTQzYTgzMGJkLTA0NzMtNDNiMS1hNGM5LWJiZWIxMzllYzAxNi5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1mM2NhOTJjMzNlZGQxNDQ5ZjY1MGFhNjA1OTYwYjRhYTI3MWU3YjhlZjEwYjZmYmU5NmEzZWU2ZWMzMjQwOWJiJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.m79xnFxID8P_114g3x65EMjXeFpj_StbIAWnFPVMs9c "chasis ")](http://https://private-user-images.githubusercontent.com/147768482/452440924-43a830bd-0473-43b1-a4c9-bbeb139ec016.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTI0LTQzYTgzMGJkLTA0NzMtNDNiMS1hNGM5LWJiZWIxMzllYzAxNi5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1mM2NhOTJjMzNlZGQxNDQ5ZjY1MGFhNjA1OTYwYjRhYTI3MWU3YjhlZjEwYjZmYmU5NmEzZWU2ZWMzMjQwOWJiJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.m79xnFxID8P_114g3x65EMjXeFpj_StbIAWnFPVMs9c "chasis ")

[![](https://private-user-images.githubusercontent.com/147768482/452440921-7f2d57ec-28e8-406a-b306-d1da54f44467.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTIxLTdmMmQ1N2VjLTI4ZTgtNDA2YS1iMzA2LWQxZGE1NGY0NDQ2Ny5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1hM2M0YTk4MGJjZmViNDZjZTU3NWU5NGQ2YjViNjQ0Y2ZjZDU5ODQ1NjcyYWIxNzc3YTE0ZDk1OGI4MDRjN2YyJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.WmrkOCiTafj0QyTmyxjL1cyLML15lcGE_XQuN2gwS4o)](http://https://private-user-images.githubusercontent.com/147768482/452440921-7f2d57ec-28e8-406a-b306-d1da54f44467.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTIxLTdmMmQ1N2VjLTI4ZTgtNDA2YS1iMzA2LWQxZGE1NGY0NDQ2Ny5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1hM2M0YTk4MGJjZmViNDZjZTU3NWU5NGQ2YjViNjQ0Y2ZjZDU5ODQ1NjcyYWIxNzc3YTE0ZDk1OGI4MDRjN2YyJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.WmrkOCiTafj0QyTmyxjL1cyLML15lcGE_XQuN2gwS4o)

## **Guia de armado**
En esta seccion se encontraran con un paso a paso de nuestro proceso  de armado, una guia sencilla y completa de nuestro proceso. Para empezar se adjunta un link del armado del chasis a disposici√≥n p√∫blica, el cual utilizamos como recurso para optimizar mejor el tiempo.


https://dukedoks.com/portfolio/guia-chasis-rc/

### **archivos de impresion de chasis fotos de la impresion**



## üîß Materiales y Componentes
Lista detallada de los componentes utilizados:
- **Chasis de referencias de modelado 3D**
- **Motor DC 9V kit ultimate 2.0**
- **Servo Motor Futaba S3003 08-sd-025**
- **Arduino Mega 2560**
- **Bater√≠a de litio 18650 (3 UND)**
- **Puente H L298N**
- **Sensor de ultrasonido de distancia Arduino HC-SR04 (3 UND)**
- **Controlador de velocidad PWM motores DC 4.5V-35V 5A 90W**


**Servo motor FUTABA S3003**

[![servomotor ](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRCsksBOFdDB5BY8tKZa6eUbbB8zCaAIml6zw&s "servomotor ")](http://https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRCsksBOFdDB5BY8tKZa6eUbbB8zCaAIml6zw&s "servomotor ")

Descripci√≥n: Servo est√°ndar de 180¬∞ usado en rob√≥tica y modelismo, con engranajes de nylon 214.

Ventajas:

1. Precisi√≥n: Control angular exacto mediante se√±ales PWM 14.

2. Costo bajo: Opci√≥n econ√≥mica para proyectos b√°sicos 10.

3. Compatibilidad: Funciona con Arduino (ejemplo: control de brazos rob√≥ticos) 10.

Desventajas:

 1. Torque limitado: 3.2 kg/cm a 4.8V (insuficiente para cargas pesadas) 2.

2. Fragilidad: Engranajes de nylon propensos a desgaste 14.

3. Voltaje cr√≠tico: Requiere regulaci√≥n precisa (recomendado 6V con UBEC)

**Arduino uno**

![Arduino1-3](https://github.com/user-attachments/assets/68743773-d612-4e50-b748-177711cdb51a)


El Arduino Mega 2560 es una placa de desarrollo basada en el microcontrolador ATmega2560, dise√±ada para proyectos que requieren m√°s pines de E/S y memoria que modelos como el Arduino Uno. Es ampliamente utilizado en rob√≥tica, automatizaci√≥n y sistemas de control complejos.

‚úÖ 3 Ventajas del Arduino Uno
F√°cil de usar y aprender

Ideal para principiantes gracias a su entorno de desarrollo intuitivo y abundante documentaci√≥n.

Gran comunidad y soporte

Miles de tutoriales, foros y ejemplos disponibles para resolver dudas y compartir proyectos.

Compatible con muchos m√≥dulos y sensores

Puedes conectar f√°cilmente pantallas, motores, sensores, y m√°s sin complicaciones.

‚ùå 3 Desventajas del Arduino Uno
Capacidad limitada de memoria y procesamiento

Solo 32 KB de memoria flash y 2 KB de RAM, lo que restringe proyectos complejos.

Sin conectividad inal√°mbrica integrada

No incluye Wi-Fi ni Bluetooth, lo que requiere m√≥dulos adicionales para conectividad.

Tama√±o relativamente grande

Puede ser inc√≥modo para proyectos compactos o port√°tiles; hay placas m√°s peque√±as como el Arduino Nano.


**Bater√≠as De Litio 18650 3.7V a 7800mA**

[![](https://http2.mlstatic.com/D_NQ_NP_881915-MLV71037692218_082023-O.webp)](http://https://http2.mlstatic.com/D_NQ_NP_881915-MLV71037692218_082023-O.webp)

**Puente H L298N**

![Sin t√≠tulopuente h rojo](https://github.com/user-attachments/assets/c998e194-728f-4ca4-acd2-dbf268346189)

 **Sensor de ultrasonido de distancia Arduino HC-SR04**

![ultrasinico](https://github.com/user-attachments/assets/902c8c8b-0308-4dfd-9ffe-1c58e8a6bf10)
 
**Switches** 

[![suiche](https://sumador.com/cdn/shop/products/Suichetipobalancinde2pines2.jpg?v=1588622314 "suiche")](http://https://sumador.com/cdn/shop/products/Suichetipobalancinde2pines2.jpg?v=1588622314 "suiche")

**motor motor Makeblock 9VDC de 185 RPM**

![motor makeblock 9v](https://github.com/user-attachments/assets/8a9cdd8b-57d4-416b-b355-9b4c4810f2ba)

### **Descripcion**

El motor Makeblock 9VDC de 185 RPM es el motor m√°s com√∫nmente utilizado en la plataforma Makeblock o proyectos de robotica en general. Est√° impulsado por corriente continua y es la opci√≥n ideal para que las cosas se muevan en todo tipo de proyectos.

### Ventajas:

1. Alto torque: Ideales para cargas medias gracias a su caja reductora (ejemplo: 185 RPM para modelos de 9V) 

2. Compatibilidad: Integrados con placas como MegaPi (basada en Arduino Mega 2560) 

3. Durabilidad: Piezas de aluminio anodizado en el kit Ultimate 2.0 9.

#### Desventajas:

1. Consumo energ√©tico: Requieren bater√≠as de 9V (6xAA) o fuente externa 13.

2. Control complejo: Necesitan drivers como el L298N para PWM 9.

3. Ruido: Los engranajes pueden generar sonido en cargas altas 

## üî® Instalaci√≥n y Montaje
Pasos de montaje mec√°nico y el√©ctrico de los compo
nentes:

Diagrama de conexiones del sistema el√©ctrico.

![circuit_image](https://github.com/user-attachments/assets/2e3a6b02-0ed8-4931-bf9c-d51e61286a32)

Para el diagrama de coneccion que se uso cirkit desirgner para poder realiza una coneccion visual de donde van los pines y como va a ir cableado todo el sistema electrico y como se compone a la hora de armar 
**Partes mec√°nicas de conexi√≥n a las ruedas**


Bajo un concepto mec√°nico manejado con pi√±ones que se conectan al motor y del motor al eje principal para tener as√≠ la transferencia de potencia directo a las ruedas, este es el montaje de la parte trasera de motor con el eje principal y el chasis.

[![motor ](https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-0-1536x864.jpg "motor ")](http://https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-0-1536x864.jpg "motor ")

[![](https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-1-1536x864.jpg)](http://https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-1-1536x864.jpg)

[![](https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-2-1536x864.jpg)](http://https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-2-1536x864.jpg)
 


**Direcci√≥n delantera**
En la parte delantera se utilizo un sistema sensillo con un servomotor conectado a una barra de direcci√≥n como puente a las ruedas.

[![](https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_04B-1-1536x864.jpg)](http://https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_04B-1-1536x864.jpg)

[![](https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_04B-2-1536x864.jpg)](http://https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_04B-2-1536x864.jpg)



5. Pruebas finales del funcionamiento del carrito RC
   
Codigo en Arduino IDE (codigo absuelto a cambios)

###Code Blocks (multi-language) & highlighting

####Inline code
#include <Servo.h>
#include <math.h> // Para la funci√≥n cos() y radians()

// --- Pines de Hardware ---
#define SW_ARRANQUE 2     // Pin para el bot√≥n de arranque (con pull-up interno)
#define ENA 3             // Pin PWM para el control de velocidad del motor (Debe ser un pin PWM, ej. 3, 5, 6, 9, 10, 11 en Arduino UNO)
#define IN1 4             // Pin de control de direcci√≥n del motor 1
#define IN2 5             // Pin de control de direcci√≥n del motor 2
#define PIN_SERVO 6       // Pin para el servo de direcci√≥n
#define TRIG_FRONTAL 7    // Pin TRIG del sensor ultras√≥nico frontal
#define ECHO_FRONTAL 8    // Pin ECHO del sensor ultras√≥nico frontal
#define TRIG_DERECHO 9    // Pin TRIG del sensor ultras√≥nico derecho
#define ECHO_DERECHO 10   // Pin ECHO del sensor ultras√≥nico derecho
#define TRIG_IZQUIERDO 11 // Pin TRIG del sensor ultras√≥nico izquierdo
#define ECHO_IZQUIERDO 12 // Pin ECHO del sensor ultras√≥nico izquierdo

// --- Par√°metros de Calibraci√≥n y Comportamiento ---
#define POS_CENTRO 94      // √Ångulo del servo para ir recto (ajustar si es necesario)
#define ANGULO_MAX_GIRO 40 // M√°ximo √°ngulo de giro para el servo (e.g., 38 grados a cada lado del centro)

#define DISTANCIA_PARADA_FRONTA 35 // Distancia en cm para detenerse frente a un muro (al inicio y en cualquier obst√°culo)
#define DISTANCIA_SEGURA 200       // Distancia en cm a partir de la cual la velocidad comienza a reducirse (para recta)
#define DISTANCIA_DESEADA_PARED_FIJA 30 // Distancia deseada al muro exterior fijo para el control PID (en cm)
#define UMBRAL_DETECCION_ESQUINA 100 // Distancia en cm que indica una 'apertura' en el sensor lateral para detectar esquina
#define UMBRAL_RECTA_SIMILARIDAD 5.0 // Umbral en cm para considerar que las paredes laterales son paralelas (fin de giro)
#define MARGEN_GIRO_DECISION 10.0 // Margen en cm para decidir la direcci√≥n de giro (si la diferencia es menor, puede que no sea una esquina clara)
#define UMBRAL_SALIDA_GIRO_FRONTAL 60 // Nueva: Distancia frontal para considerar que el robot ha salido de la esquina y puede enderezarse.

// --- Constantes PID para control de direcci√≥n ---
#define KP 0.80  // Ganancia Proporcional (ajustar)
#define KI 0.01 // Ganancia Integral (ajustar)
#define KD 0.01  // Ganancia Derivativa (ajustar)

// --- Par√°metros de Velocidad ---
#define VELOCIDAD_MAXIMA 200 // Velocidad m√°xima del motor (0-255 PWM)
#define VELOCIDAD_MINIMA 70  // Velocidad m√≠nima del motor para movimiento
#define VELOCIDAD_GIRO 100   // Velocidad del motor al girar en una esquina
#define VELOCIDAD_REVERSA 80 // Velocidad para retroceder (nueva constante)

// --- Offset del sensor lateral (IMPORTANTE: CALIBRAR ESTE VALOR) ---
// Esta es la distancia desde el sensor lateral hasta el eje de direcci√≥n del robot
// o el punto de pivote para la correcci√≥n trigonom√©trica.
// Mide esta distancia en tu robot y aj√∫stala.
#define SENSOR_LATERAL_OFFSET_CM 10.0 // Valor de ejemplo, ¬°AJUSTAR!

// --- Configuraci√≥n del Filtro de Promedio M√≥vil ---
#define FILTER_SIZE 5 // N√∫mero de muestras para el promedio m√≥vil (ajustar)

// --- Variables Globales para el Filtro de Promedio M√≥vil ---
float frontal_readings[FILTER_SIZE];
float derecha_readings[FILTER_SIZE];
float izquierda_readings[FILTER_SIZE];

int frontal_index = 0;
int derecha_index = 0;
int izquierda_index = 0;

// --- Variables Globales del Robot ---
Servo miServo; // Objeto servo

// Lecturas de los sensores ultras√≥nicos (ya filtradas)
float frontal_dist;
float derecha_dist;
float izquierda_dist;

// Almacena el √°ngulo actual del servo para correcci√≥n trigonom√©trica
int currentSteeringAngle = POS_CENTRO; 

// Variables de estado del robot
bool detenerCompletamente = false;
bool iniciado = false; // Bandera para saber si el robot ha iniciado el desaf√≠o
bool enFaseDeGiro = false; // Indica si el robot est√° actualmente ejecutando un giro de esquina

// Variables para el control de vueltas
int seccionesEsquinaPasadas = 0;
const int MAX_SECCIONES_ESQUINA = 12; // 3 vueltas * 4 esquinas/vuelta = 12 secciones de esquina

// Variable para la direcci√≥n del desaf√≠o (CLO = Clockwise, CCW = Counter-Clockwise)
// Esta variable sigue siendo necesaria para el PID en las rectas (muro fijo externo)
enum DireccionDesafio { DESCONOCIDA, CLOCKWISE, COUNTER_CLOCKWISE };
DireccionDesafio direccionActual = DESCONOCIDA;

// Variables PID
float errorAnterior = 0;
float sumaErrores = 0;
unsigned long tiempoAnteriorPID = 0;

// --- Prototipos de Funciones ---
float leerUltrasonico(uint8_t trigPin, uint8_t echoPin, float* readings_buffer, int* buffer_index);
float getCorrectedLateralDistance(float raw_distance, int servo_angle_val, float sensor_offset_cm);
void motorDelante(int velocidad);
void motorAtras(int velocidad);
void motorParar();
void setSteeringAngle(int angle);
void avanzarHastaMuroInicial();
void determinarDireccionDesafio();
void controlPID();
void detectarYContarEsquina();
void manejarEsquina();
void ajustarVelocidadEnRecta();

// --- Configuraci√≥n Inicial ---
void setup() {
  // Configuraci√≥n de pines de motor
  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  motorParar(); // Asegurarse de que el motor est√© parado al inicio

  // Configuraci√≥n de pines de sensores ultras√≥nicos
  pinMode(TRIG_FRONTAL, OUTPUT);
  pinMode(ECHO_FRONTAL, INPUT);
  pinMode(TRIG_DERECHO, OUTPUT);
  pinMode(ECHO_DERECHO, INPUT);
  pinMode(TRIG_IZQUIERDO, OUTPUT);
  pinMode(ECHO_IZQUIERDO, INPUT);

  pinMode(13, OUTPUT); // Pin 13 para LED de depuraci√≥n

  // Configuraci√≥n del bot√≥n de arranque con pull-up interno
  pinMode(SW_ARRANQUE, INPUT_PULLUP);

  // Adjuntar el servo
  miServo.attach(PIN_SERVO);
  setSteeringAngle(POS_CENTRO); // Poner las ruedas rectas al inicio
  delay(100); // Peque√±a pausa para que el servo se estabilice

  // Iniciar comunicaci√≥n serial para depuraci√≥n
  Serial.begin(9600);
  Serial.println("Sistema iniciado. Esperando boton de arranque...");
  digitalWrite(13, HIGH); // LED encendido indicando espera

  // Inicializar buffers del filtro de promedio m√≥vil con un valor por defecto
  for (int i = 0; i < FILTER_SIZE; i++) {
    frontal_readings[i] = 300.0;
    derecha_readings[i] = 400.0;
    izquierda_readings[i] = 400.0;
  }
}

// --- Bucle Principal ---
void loop() {
  // Leer el estado del bot√≥n de arranque
  if (digitalRead(SW_ARRANQUE) == LOW) { // Si el bot√≥n est√° presionado (LOW por pull-up)
    if (!iniciado) {
      Serial.println("Boton de arranque presionado. Iniciando desafio.");
      delay(50); // Antirebote
      digitalWrite(13, LOW); // LED apagado indicando inicio
      iniciado = true; // El robot ha iniciado
      detenerCompletamente = false; // Reiniciar estado de detenci√≥n
    }
  }

  if (iniciado && !detenerCompletamente) {
    // 1. Leer sensores (ahora con filtro de promedio m√≥vil)
    frontal_dist = leerUltrasonico(TRIG_FRONTAL, ECHO_FRONTAL, frontal_readings, &frontal_index);
    derecha_dist = leerUltrasonico(TRIG_DERECHO, ECHO_DERECHO, derecha_readings, &derecha_index);
    izquierda_dist = leerUltrasonico(TRIG_IZQUIERDO, ECHO_IZQUIERDO, izquierda_readings, &izquierda_index);

    // Imprimir lecturas para depuraci√≥n en Serial Monitor
    Serial.print("F:"); Serial.print(frontal_dist);
    Serial.print(" D:"); Serial.print(derecha_dist);
    Serial.print(" I:"); Serial.println(izquierda_dist);

    // --- L√≥gica del Desaf√≠o ---

    // Paso 1: Avanzar hasta el muro inicial y determinar la direcci√≥n si a√∫n no se ha hecho
    if (direccionActual == DESCONOCIDA) {
      Serial.println("Avanzando hacia el muro inicial y centrando...");
      avanzarHastaMuroInicial(); // Avanza, se detiene y usa PID para centrarse
      
      // Una vez detenido frente al muro, determina la direcci√≥n
      determinarDireccionDesafio();
      
      // Si la direcci√≥n no se pudo determinar, el robot retrocede y el loop intentar√° de nuevo.
      if (direccionActual == DESCONOCIDA) {
        Serial.println("Direccion no determinada. Retrocediendo para reintentar.");
        motorAtras(VELOCIDAD_REVERSA); // Retroceder
        delay(500); // Tiempo para retroceder
        motorParar();
        setSteeringAngle(POS_CENTRO); // Enderezar ruedas
        delay(200);
        // El loop() volver√° a ejecutar el if(direccionActual == DESCONOCIDA)
        // y reintentar√° avanzarHastaMuroInicial y determinarDireccionDesafio.
      } else {
        Serial.print("Direccion del desafio determinada: ");
        if (direccionActual == CLOCKWISE) {
          Serial.println("CLOCKWISE");
        } else if (direccionActual == COUNTER_CLOCKWISE) {
          Serial.println("COUNTER_CLOCKWISE");
        }
        Serial.println("Listo para seguir el carril.");
        delay(20); // Peque√±a pausa para ver el mensaje
      }
    } else {
      // Si la direcci√≥n ya est√° determinada, el robot est√° en el ciclo de seguimiento de carril y vueltas
      if (!enFaseDeGiro) { // Solo ajustar velocidad y PID si no est√° en una fase de giro activa
        ajustarVelocidadEnRecta(); // Ajustar velocidad basada en la distancia frontal (generalizado)
        controlPID();              // Mantenerse en el centro del carril
      }
      detectarYContarEsquina();  // Detectar y contar esquinas (llama a manejarEsquina si detecta)
    }

    // Comprobar si se han completado las 3 vueltas
    if (seccionesEsquinaPasadas >= MAX_SECCIONES_ESQUINA) {
      Serial.println("3 vueltas completadas! Deteniendo el robot.");
      motorParar();
      detenerCompletamente = true; // Detener completamente el robot
      iniciado = false; // Resetear el estado para que no vuelva a entrar en el bucle principal
      digitalWrite(13, HIGH); // Encender LED para indicar fin del desaf√≠o
    }
  } else if (detenerCompletamente) {
    motorParar(); // Asegurarse de que el motor est√© parado
    setSteeringAngle(POS_CENTRO); // Ruedas rectas al finalizar
    delay(10); // Peque√±a pausa para no saturar el serial
  }
}

// --- Implementaci√≥n de Funciones Auxiliares ---

/**
 * @brief Lee la distancia de un sensor ultras√≥nico y aplica un filtro de promedio m√≥vil.
 * @param trigPin El pin TRIG del sensor.
 * @param echoPin El pin ECHO del sensor.
 * @param readings_buffer Puntero al array (buffer) de lecturas para el filtro.
 * @param buffer_index Puntero al √≠ndice actual en el buffer.
 * @return La distancia filtrada en cent√≠metros.
 */
float leerUltrasonico(uint8_t trigPin, uint8_t echoPin, float* readings_buffer, int* buffer_index) {
  // Realizar una lectura cruda del sensor
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duracion = pulseIn(echoPin, HIGH);
  float raw_distanceCm = duracion * 0.034 / 2;

  // Filtrado simple de valores extremos antes de a√±adir al buffer
  if (raw_distanceCm == 0 || raw_distanceCm > 400 || raw_distanceCm < 2) { 
    raw_distanceCm = 400.0; // Asignar un valor grande para lecturas fuera de rango
  }

  // A√±adir la nueva lectura al buffer circular
  readings_buffer[*buffer_index] = raw_distanceCm;
  *buffer_index = (*buffer_index + 1) % FILTER_SIZE; // Mover al siguiente √≠ndice, envolviendo al inicio

  // Calcular el promedio de las lecturas en el buffer
  float sum = 0;
  for (int i = 0; i < FILTER_SIZE; i++) {
    sum += readings_buffer[i];
  }
  return sum / FILTER_SIZE;
}

/**
 * @brief Corrige la distancia le√≠da por un sensor lateral bas√°ndose en el √°ngulo de direcci√≥n del servo.
 * Esto compensa cuando el sensor no est√° perpendicular a la pared debido a un giro.
 * @param raw_distance La lectura de distancia cruda del sensor lateral.
 * @param servo_angle_val El √°ngulo actual del servo de direcci√≥n (currentSteeringAngle).
 * @param sensor_offset_cm Distancia del sensor al eje de giro del veh√≠culo (longitudinal).
 * @return La distancia estimada corregida a la pared.
 */
float getCorrectedLateralDistance(float raw_distance, int servo_angle_val, float sensor_offset_cm) {
  // Calcular el √°ngulo de desviaci√≥n del servo respecto al centro.
  float angle_deviation_degrees = (float)servo_angle_val - POS_CENTRO; // Puede ser positivo o negativo
  
  // Convertir grados a radianes para la funci√≥n cos() y sin()
  float angle_deviation_radians = radians(angle_deviation_degrees);
  
  // Si raw_distance es muy grande (no hay pared), la correcci√≥n no tiene sentido.
  if (raw_distance > UMBRAL_DETECCION_ESQUINA) { 
      return raw_distance;
  }

  // F√≥rmula trigonom√©trica para la distancia perpendicular real a la pared.
  // Se asume que el sensor est√° montado de forma que su eje de medici√≥n es perpendicular al robot cuando el servo est√° en POS_CENTRO.
  // Cuando el servo gira, el sensor se inclina. La distancia perpendicular real a la pared es raw_distance * cos(√°ngulo_desviaci√≥n).
  // El 'sensor_offset_cm' es la distancia longitudinal del sensor al eje de giro.
  // Si el sensor est√° delante del eje de giro y gira hacia la pared, la lectura es menor de lo que deber√≠a ser perpendicular.
  // Si el sensor est√° detr√°s del eje de giro y gira hacia la pared, la lectura es mayor de lo que deber√≠a ser perpendicular.
  // Una aproximaci√≥n podr√≠a ser: corrected_dist = raw_distance * cos(angle_deviation_radians) + sensor_offset_cm * sin(angle_deviation_radians);
  // Sin embargo, esto puede introducir m√°s ruido si el offset no se calibra perfectamente.
  // Para este desaf√≠o, raw_distance * cos(angle_deviation_radians) es un buen punto de partida.

  return raw_distance * cos(angle_deviation_radians); // Simplificado a la proyecci√≥n coseno
}


// Funci√≥n para mover el motor hacia adelante
void motorDelante(int velocidad) {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  analogWrite(ENA, constrain(velocidad, 0, 255)); // Limitar velocidad entre 0 y 255
}

// Funci√≥n para mover el motor hacia atr√°s (no se usa en este desaf√≠o, pero √∫til)
void motorAtras(int velocidad) {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  analogWrite(ENA, constrain(velocidad, 0, 255));
}

// Funci√≥n para detener el motor
void motorParar() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  analogWrite(ENA, 0); // Detener el motor
}

// Funci√≥n para establecer el √°ngulo del servo de direcci√≥n
void setSteeringAngle(int angle) {
  // Limitar el √°ngulo para evitar que el servo exceda sus l√≠mites mec√°nicos
  currentSteeringAngle = constrain(angle, POS_CENTRO - ANGULO_MAX_GIRO, POS_CENTRO + ANGULO_MAX_GIRO); 
  miServo.write(currentSteeringAngle);
}

// --- Funciones de L√≥gica del Desaf√≠o ---

// El robot avanza hasta que el sensor frontal detecta un muro a DISTANCIA_PARADA_FRONTA
// Y utiliza PID para mantenerse centrado en el carril.
void avanzarHastaMuroInicial() {
  float velActual;

  while (frontal_dist > DISTANCIA_PARADA_FRONTA) { // Se detiene a DISTANCIA_PARADA_FRONTA
    frontal_dist = leerUltrasonico(TRIG_FRONTAL, ECHO_FRONTAL, frontal_readings, &frontal_index);
    derecha_dist = leerUltrasonico(TRIG_DERECHO, ECHO_DERECHO, derecha_readings, &derecha_index);
    izquierda_dist = leerUltrasonico(TRIG_IZQUIERDO, ECHO_IZQUIERDO, izquierda_readings, &izquierda_index);

    Serial.print("Avz. Inicial: F:"); Serial.print(frontal_dist);
    Serial.print(" D:"); Serial.print(derecha_dist);
    Serial.print(" I:"); Serial.println(izquierda_dist);

    // Ajustar velocidad: m√°s r√°pido cuando est√° lejos, m√°s lento cuando est√° cerca
    velActual = map(frontal_dist, DISTANCIA_PARADA_FRONTA, DISTANCIA_SEGURA, VELOCIDAD_MINIMA, VELOCIDAD_MAXIMA);
    velActual = constrain(velActual, VELOCIDAD_MINIMA, VELOCIDAD_MAXIMA);
    motorDelante(velActual);
    
    // Aplicar PID para centrarse en el carril, incluso antes de conocer la direcci√≥n
    // En este estado, el PID buscar√° igualar las distancias izquierda y derecha.
    controlPID(); // controlPID ahora maneja el estado DESCONOCIDA para centrado.

    delay(20); // Peque√±a pausa para lecturas estables y fluidez
  }
  motorParar(); // Detener completamente al alcanzar la distancia de parada
  Serial.println("Detenido frente al muro inicial.");
  delay(200); // Pausa para estabilizar despu√©s de la parada
}

// Determina la direcci√≥n del desaf√≠o (Clockwise o Counter-Clockwise)
// Asume que al detenerse frente al muro inicial, un lado estar√° m√°s "abierto" que el otro.
void determinarDireccionDesafio() {
  // Despu√©s de detenerse frente al muro, leer de nuevo los sensores laterales
  derecha_dist = leerUltrasonico(TRIG_DERECHO, ECHO_DERECHO, derecha_readings, &derecha_index);
  izquierda_dist = leerUltrasonico(TRIG_IZQUIERDO, ECHO_IZQUIERDO, izquierda_readings, &izquierda_index);

  Serial.print("Determinado direccion: Derecha: "); Serial.print(derecha_dist);
  Serial.print(", Izquierda: "); Serial.println(izquierda_dist);
  delay(200);

  float diferencia = abs(derecha_dist - izquierda_dist);
  float margen_error_ultrasonico = 10.0; // Margen para la precisi√≥n del sensor

  if (diferencia > margen_error_ultrasonico) {
    if (derecha_dist > izquierda_dist) {
      direccionActual = CLOCKWISE;
      Serial.println("Direccion: CLOCKWISE");
    } else {
      direccionActual = COUNTER_CLOCKWISE;
      Serial.println("Direccion: COUNTER_CLOCKWISE");
    }
  } else {
    Serial.println("No se pudo determinar la direccion del desafio, retrocediendo para reintentar...");
    digitalWrite(13, HIGH); // Encender led para indicar que no se determin√≥ la direcci√≥n del desaf√≠o
    direccionActual = DESCONOCIDA; // Resetear la direcci√≥n para forzar un reintento en el loop principal
  }
}

// Control PID para mantener el robot en el centro del carril
void controlPID() {
  float error = 0;
  // Pasar SENSOR_LATERAL_OFFSET_CM como tercer argumento
  float corrected_izquierda_dist = getCorrectedLateralDistance(izquierda_dist, currentSteeringAngle, SENSOR_LATERAL_OFFSET_CM);
  float corrected_derecha_dist = getCorrectedLateralDistance(derecha_dist, currentSteeringAngle, SENSOR_LATERAL_OFFSET_CM);

  if (direccionActual == DESCONOCIDA) {
    // Si la direcci√≥n es desconocida (fase inicial), intentar centrarse entre ambas paredes.
    // Error positivo significa que la izquierda est√° m√°s lejos que la derecha, el robot est√° m√°s cerca de la pared derecha, necesita girar a la izquierda.
    // Error negativo significa que la izquierda est√° m√°s cerca que la derecha, el robot est√° m√°s cerca de la pared izquierda, necesita girar a la derecha.
    error = corrected_izquierda_dist - corrected_derecha_dist;
  } else if (direccionActual == CLOCKWISE) {
    // Si va en sentido horario (CW), el muro fijo (externo) est√° a la izquierda.
    // El PID controla la distancia a este muro.
    error = corrected_izquierda_dist - DISTANCIA_DESEADA_PARED_FIJA;
  } else if (direccionActual == COUNTER_CLOCKWISE) {
    // Si va en sentido anti-horario (CCW), el muro fijo (externo) est√° a la derecha.
    // El PID controla la distancia a este muro.
    error = corrected_derecha_dist - DISTANCIA_DESEADA_PARED_FIJA;
  }

  unsigned long tiempoActualPID = millis();
  float deltaTime = (tiempoActualPID - tiempoAnteriorPID) / 1000.0; // Convertir a segundos
  if (deltaTime == 0) deltaTime = 0.001; // Evitar division por cero
  tiempoAnteriorPID = tiempoActualPID;

  // Componente Proporcional
  float p_term = KP * error;

  // Componente Integral (anti-windup simple)
  sumaErrores += error * deltaTime;
  // Limitar la suma de errores para evitar saturaci√≥n del integrador
  if (sumaErrores > 200) sumaErrores = 200;
  if (sumaErrores < -200) sumaErrores = -200;
  float i_term = KI * sumaErrores;

  // Componente Derivativo
  float d_term = KD * ((error - errorAnterior) / deltaTime);
  errorAnterior = error;

  // Calcular la correcci√≥n total del PID
  float correccion = p_term + i_term + d_term;

  // Ajustar el √°ngulo del servo
  int anguloServo = POS_CENTRO;

  // La l√≥gica de ajuste del √°ngulo del servo depende de la direcci√≥n del desaf√≠o
  // y de si estamos en la fase DESCONOCIDA.
  if (direccionActual == CLOCKWISE || direccionActual == DESCONOCIDA) {
    // Para CW (muro fijo a la izquierda) o DESCONOCIDA (centrado):
    // Si error > 0 (lejos de pared izquierda en CW, o m√°s cerca de derecha en DESCONOCIDA), necesita girar a la izquierda (√°ngulo < POS_CENTRO)
    // Si error < 0 (cerca de pared izquierda en CW, o m√°s cerca de izquierda en DESCONOCIDA), necesita girar a la derecha (√°ngulo > POS_CENTRO)
    anguloServo = POS_CENTRO - (int)correccion; // Invertir correcci√≥n para que un error positivo gire a la izquierda
  } else if (direccionActual == COUNTER_CLOCKWISE) {
    // Para CCW (muro fijo a la derecha):
    // Si error > 0 (lejos de pared derecha), necesita girar a la derecha (√°ngulo > POS_CENTRO)
    // Si error < 0 (cerca de pared derecha), necesita girar a la izquierda (√°ngulo < POS_CENTRO)
    anguloServo = POS_CENTRO + (int)correccion; // Error positivo debe girar a la derecha
  }

  setSteeringAngle(anguloServo);
  Serial.print("PID Err:"); Serial.print(error);
  Serial.print(" Corr:"); Serial.print(correccion);
  Serial.print(" Ang:"); Serial.println(anguloServo);
}

// Detecta el paso por una secci√≥n de esquina y actualiza el contador de vueltas.
void detectarYContarEsquina() {
  bool esEsquinaDetectada = false;

  // Detecci√≥n de esquina:
  // Se detecta una esquina si el camino frontal est√° despejado
  // Y al menos uno de los sensores laterales detecta una apertura significativa.
  if (frontal_dist > (DISTANCIA_PARADA_FRONTA + 10) && 
      (derecha_dist > UMBRAL_DETECCION_ESQUINA || izquierda_dist > UMBRAL_DETECCION_ESQUINA)) { 
    esEsquinaDetectada = true;
  }

  // L√≥gica para contar la esquina solo una vez por esquina y manejar el giro
  static bool enTramoRectoPrevioEsquina = true; // Estado para evitar doble conteo y asegurar transici√≥n
  
  if (esEsquinaDetectada && enTramoRectoPrevioEsquina && !enFaseDeGiro) {
    Serial.println("¬°Potencial esquina detectada! Iniciando manejo de esquina...");
    enFaseDeGiro = true; // Entrar en fase de giro
    enTramoRectoPrevioEsquina = false; // Resetear para la siguiente esquina
    manejarEsquina(); // Ejecutar la l√≥gica de giro
    // Despu√©s de manejar la esquina, el robot ya deber√≠a estar en la siguiente recta, listo para PID.
    seccionesEsquinaPasadas++;
    Serial.print("Esquina completada. Secciones pasadas: "); Serial.println(seccionesEsquinaPasadas);
    delay(200); // Pausa para ver el mensaje
    enFaseDeGiro = false; // Salir de la fase de giro una vez que se complet√≥
  } else if (!esEsquinaDetectada && !enTramoRectoPrevioEsquina && !enFaseDeGiro) {
    // Una vez que el robot ha salido de la esquina y no est√° en fase de giro
    // y los sensores ya no detectan una esquina, se considera que est√° en una recta de nuevo.
    enTramoRectoPrevioEsquina = true; 
  }
}

/**
 * @brief Maneja el giro en una esquina. El robot gira las ruedas y avanza hasta que los sensores
 * indican que ha completado la curva y ha entrado en una nueva secci√≥n recta.
 */
void manejarEsquina() {
  Serial.println("Manejando esquina...");
  motorParar(); // Detener brevemente antes de iniciar el giro o ajustar el √°ngulo
  delay(50); // Peque√±a pausa para estabilizar

  // --- Decidir la direcci√≥n de giro basada en la mayor amplitud ---
  // Se usan las lecturas filtradas globales (frontal_dist, derecha_dist, izquierda_dist)
  // que ya se actualizan continuamente en el loop principal.
  
  int anguloDeGiro = POS_CENTRO;
  Serial.print("Decision de giro: Derecha: "); Serial.print(derecha_dist);
  Serial.print(", Izquierda: "); Serial.println(izquierda_dist);

  // Se a√±ade una condici√≥n para asegurar que al menos uno de los lados realmente est√° "abierto"
  // para evitar giros en falso si el robot est√° en un tramo recto pero con lecturas ruidosas.
  if (derecha_dist > UMBRAL_DETECCION_ESQUINA && izquierda_dist > UMBRAL_DETECCION_ESQUINA) {
      // Si ambos lados est√°n muy abiertos, elegir el que tenga mayor amplitud.
      if (derecha_dist > izquierda_dist) {
          anguloDeGiro = POS_CENTRO + ANGULO_MAX_GIRO; // Girar a la derecha
          Serial.println("Girando ruedas a la derecha (ambos abiertos, derecha mas).");
      } else {
          anguloDeGiro = POS_CENTRO - ANGULO_MAX_GIRO; // Girar a la izquierda
          Serial.println("Girando ruedas a la izquierda (ambos abiertos, izquierda mas).");
      }
  } else if (derecha_dist > UMBRAL_DETECCION_ESQUINA) {
      anguloDeGiro = POS_CENTRO + ANGULO_MAX_GIRO + 10; // Girar a la derecha
      Serial.println("Girando ruedas a la derecha (derecha abierta).");
  } else if (izquierda_dist > UMBRAL_DETECCION_ESQUINA) {
      anguloDeGiro = POS_CENTRO - ANGULO_MAX_GIRO; // Girar a la izquierda
      Serial.println("Girando ruedas a la izquierda (izquierda abierta).");
  } else {
      // Si ninguna apertura clara se detecta, esto es un caso inesperado en una esquina.
      // Como fallback, se puede intentar un giro predefinido o detenerse.
      // Aqu√≠, usaremos la direcci√≥n general del desaf√≠o como un √∫ltimo recurso.
      Serial.println("Ninguna apertura clara detectada en esquina. Usando direccion general.");
      if (direccionActual == CLOCKWISE) {
          anguloDeGiro = POS_CENTRO + ANGULO_MAX_GIRO;
      } else if (direccionActual == COUNTER_CLOCKWISE) {
          anguloDeGiro = POS_CENTRO - ANGULO_MAX_GIRO;
      } else {
          // Si ni siquiera la direcci√≥n general est√° definida, girar a la derecha por defecto.
          anguloDeGiro = POS_CENTRO + ANGULO_MAX_GIRO + 10;
          Serial.println("Direccion general desconocida, girando a la derecha por defecto.");
      }
  }

  setSteeringAngle(anguloDeGiro);
  delay(100); // Dar tiempo al servo para alcanzar la posici√≥n

  motorDelante(VELOCIDAD_GIRO); // Moverse a velocidad reducida durante el giro

  // 2. Esperar a que el robot complete el giro bas√°ndose en las lecturas de los sensores
  // El giro termina cuando:
  // a) El sensor frontal no detecta obst√°culos cercanos (el camino est√° despejado)
  // b) Ambos sensores laterales (corregidos) detectan paredes a una distancia similar y razonable,
  //    indicando que el robot ha entrado en una nueva secci√≥n recta.

  unsigned long tiempoInicioGiro = millis();
  const long TIMEOUT_GIRO = 5500; // Aumentado a 5.5 segundos para dar m√°s tiempo al giro

  while (millis() - tiempoInicioGiro < TIMEOUT_GIRO) {
    frontal_dist = leerUltrasonico(TRIG_FRONTAL, ECHO_FRONTAL, frontal_readings, &frontal_index);
    derecha_dist = leerUltrasonico(TRIG_DERECHO, ECHO_DERECHO, derecha_readings, &derecha_index);
    izquierda_dist = leerUltrasonico(TRIG_IZQUIERDO, ECHO_IZQUIERDO, izquierda_readings, &izquierda_index);

    // Pasar SENSOR_LATERAL_OFFSET_CM como tercer argumento
    float corrected_derecha = getCorrectedLateralDistance(derecha_dist, currentSteeringAngle, SENSOR_LATERAL_OFFSET_CM);
    float corrected_izquierda = getCorrectedLateralDistance(izquierda_dist, currentSteeringAngle, SENSOR_LATERAL_OFFSET_CM);

    Serial.print("Girando... F:"); Serial.print(frontal_dist);
    Serial.print(" CD:"); Serial.print(corrected_derecha);
    Serial.print(" CI:"); Serial.println(corrected_izquierda);

    // --- Depuraci√≥n de las condiciones de salida del giro ---
    Serial.print("Condiciones de salida: ");
    Serial.print("F_OK: "); Serial.print(frontal_dist > UMBRAL_SALIDA_GIRO_FRONTAL);
    Serial.print(", CD_OK: "); Serial.print(corrected_derecha < UMBRAL_DETECCION_ESQUINA);
    Serial.print(", CI_OK: "); Serial.print(corrected_izquierda < UMBRAL_DETECCION_ESQUINA);
    Serial.print(", SIM_OK: "); Serial.println(abs(corrected_derecha - corrected_izquierda) < UMBRAL_RECTA_SIMILARIDAD);
    // --- Fin de Depuraci√≥n ---

    // Condici√≥n de salida del giro:
    // 1. Camino frontal despejado (ya no est√° 'pegado' al muro de la esquina)
    // 2. Ambos lados detectan paredes (no apertura)
    // 3. Las distancias laterales corregidas son "similares" (ha enderezado y est√° en una recta)
    if (frontal_dist > UMBRAL_SALIDA_GIRO_FRONTAL &&
        corrected_derecha < UMBRAL_DETECCION_ESQUINA &&
        corrected_izquierda < UMBRAL_DETECCION_ESQUINA &&
        abs(corrected_derecha - corrected_izquierda) < UMBRAL_RECTA_SIMILARIDAD) {
      Serial.println("Fin del giro detectado: En nueva recta.");
      break; // Salir del bucle de giro
    }
    delay(80); // Peque√±a pausa
  }
  
  if (millis() - tiempoInicioGiro >= TIMEOUT_GIRO) {
    Serial.println("Timeout en el giro. Puede que no haya detectado el fin de la esquina correctamente.");
    digitalWrite(13, HIGH); // Encender LED si hay timeout en el giro
  }

  motorParar(); // Detener al final del giro para asegurar la estabilidad
  setSteeringAngle(POS_CENTRO); // Volver las ruedas rectas
  delay(50); // Peque√±a pausa antes de continuar
}

/**
 * @brief Ajusta la velocidad del robot en los tramos rectos.
 * La velocidad es proporcional a la distancia del muro frontal, disminuyendo a medida que se acerca.
 */
void ajustarVelocidadEnRecta() {
  if (frontal_dist > DISTANCIA_PARADA_FRONTA) {
    int velocidadAdaptativa = map(frontal_dist, DISTANCIA_PARADA_FRONTA, DISTANCIA_SEGURA, VELOCIDAD_MINIMA, VELOCIDAD_MAXIMA);
    velocidadAdaptativa = constrain(velocidadAdaptativa, VELOCIDAD_MINIMA, VELOCIDAD_MAXIMA);
    motorDelante(velocidadAdaptativa);
    Serial.print("Velocidad adaptativa en recta: "); Serial.println(velocidadAdaptativa);
  } else {
    motorParar(); 
    Serial.println("Muro frontal detectado, deteniendo en ajustarVelocidadEnRecta.");
    delay(100); // Peque√±a pausa para ver el mensaje de detenci√≥n
  }
}

###End
