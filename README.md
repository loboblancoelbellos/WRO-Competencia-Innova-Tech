## 游 Documentacion de ingenieria - Innova Tech

Este repositorio contiene todos los materiales necesarios para crear a "Ledma Tech_MK1", el robot aut칩nomo creado por el equipo "Innova Tech", que participar치 en la categor칤a Futuros ingeniero en la Clasificaion de la World Robot Olympiad en la temporada 2025.

##  Contenido 

- Miembros del equipo 
- introduccion 
- dise침o adaptado 
-  Materiales y Componentes


## 游닀 Introducci칩n
En este repositorio se observar치 un arduo proceso tanto de selecci칩n, as칤 como de armado del carrito RC, para la categor칤a Futuros Ingenieros de la WRO. Fue un proceso realizado con gran esfuerzo, independientemente de las dificultades. Un trabajo en equipo y dedicaci칩n para dar lo mejor de nosotros en la demostraci칩n a los jueces, conociendo las bases de la rob칩tica y aprendiendo mucho en el proceso nos basamos en mec치nica, electr칩nica y programaci칩n, pensando siempre en aprender m치s para presentar as칤 un proyecto capaz de desempe침ar 칩ptimamente y aut칩nomamente todos los objetivos.





## Miembros del equipo 
-Leontino Jose Medina Di Donato

-Adriana Carolina Palmar Molero

-Dharma Alexandra Pe침a Jim칠nez

Somos jovenes estudiantes de ingenier칤a, donde nos conocimos en las aulas de la institucion como futuros ingenieros, al comienzo de la carrera y decidimos participar en la competencia por la pasi칩n que compartimos de armar proyectos. La competencia nos llamo la atencion para poder expandir nuestros conocimientos de rob칩tica, y explotar nuestras capacidades como un equipo de jovenes que buscan mirar m치s all치 de sus fronteras. 

![WhatsApp Image 2025-06-07 at 17 47 40](https://github.com/user-attachments/assets/3568e8a1-b1b9-4abf-abde-68d06ec69484)


**Chasis de referencias de modelado 3D**

Al comienzo de nuestra inmersi칩n para esta competencia, decidimos explotar al m치ximo todos los recursos disponibles a nuestra disposici칩n, entre ellos los muchos modelos que hay en internet de modelado 3D para chasis, entre ellos encontramos uno que nos funcionaba en muchos factores, ya sea tiempo, factibilidad, est칠tica, etc. Aqu칤 dejamos el link a disposicion para mas informaci칩n adem치s de adjuntar la imagen de referencia y las im치genes de nuestro chasis post impresi칩n 3D.




 https://cults3d.com/es/modelo-3d/juegos/casis-1-10-adaptable

![Chasis-RC-02](https://github.com/user-attachments/assets/9e7c69a4-fcab-4fcb-8af9-bcbd09175e0b)

### **Chasis Armado**

[![](https://private-user-images.githubusercontent.com/147768482/452440916-3ea8a2ea-8c3c-4cf5-b728-1cdf928101bc.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTE2LTNlYThhMmVhLThjM2MtNGNmNS1iNzI4LTFjZGY5MjgxMDFiYy5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1hYWU5ZjdkZWI2OTg3MGQ3ZDA1YWY3M2M0NGQxZTM2NGY3ZWYzNDdhMmQ3MDA0YmI4ZmI1MTAwMWQzM2Q5ZjIxJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.gCb0gfFzAoQ2r3PP932QrQqkEkITuoaZtzW44D_CnMI)](http://https://private-user-images.githubusercontent.com/147768482/452440916-3ea8a2ea-8c3c-4cf5-b728-1cdf928101bc.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTE2LTNlYThhMmVhLThjM2MtNGNmNS1iNzI4LTFjZGY5MjgxMDFiYy5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1hYWU5ZjdkZWI2OTg3MGQ3ZDA1YWY3M2M0NGQxZTM2NGY3ZWYzNDdhMmQ3MDA0YmI4ZmI1MTAwMWQzM2Q5ZjIxJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.gCb0gfFzAoQ2r3PP932QrQqkEkITuoaZtzW44D_CnMI)

[![chasis ](https://private-user-images.githubusercontent.com/147768482/452440924-43a830bd-0473-43b1-a4c9-bbeb139ec016.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTI0LTQzYTgzMGJkLTA0NzMtNDNiMS1hNGM5LWJiZWIxMzllYzAxNi5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1mM2NhOTJjMzNlZGQxNDQ5ZjY1MGFhNjA1OTYwYjRhYTI3MWU3YjhlZjEwYjZmYmU5NmEzZWU2ZWMzMjQwOWJiJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.m79xnFxID8P_114g3x65EMjXeFpj_StbIAWnFPVMs9c "chasis ")](http://https://private-user-images.githubusercontent.com/147768482/452440924-43a830bd-0473-43b1-a4c9-bbeb139ec016.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTI0LTQzYTgzMGJkLTA0NzMtNDNiMS1hNGM5LWJiZWIxMzllYzAxNi5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1mM2NhOTJjMzNlZGQxNDQ5ZjY1MGFhNjA1OTYwYjRhYTI3MWU3YjhlZjEwYjZmYmU5NmEzZWU2ZWMzMjQwOWJiJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.m79xnFxID8P_114g3x65EMjXeFpj_StbIAWnFPVMs9c "chasis ")

[![](https://private-user-images.githubusercontent.com/147768482/452440921-7f2d57ec-28e8-406a-b306-d1da54f44467.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTIxLTdmMmQ1N2VjLTI4ZTgtNDA2YS1iMzA2LWQxZGE1NGY0NDQ2Ny5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1hM2M0YTk4MGJjZmViNDZjZTU3NWU5NGQ2YjViNjQ0Y2ZjZDU5ODQ1NjcyYWIxNzc3YTE0ZDk1OGI4MDRjN2YyJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.WmrkOCiTafj0QyTmyxjL1cyLML15lcGE_XQuN2gwS4o)](http://https://private-user-images.githubusercontent.com/147768482/452440921-7f2d57ec-28e8-406a-b306-d1da54f44467.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDkyMzc3MTksIm5iZiI6MTc0OTIzNzQxOSwicGF0aCI6Ii8xNDc3Njg0ODIvNDUyNDQwOTIxLTdmMmQ1N2VjLTI4ZTgtNDA2YS1iMzA2LWQxZGE1NGY0NDQ2Ny5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYwNlQxOTE2NTlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1hM2M0YTk4MGJjZmViNDZjZTU3NWU5NGQ2YjViNjQ0Y2ZjZDU5ODQ1NjcyYWIxNzc3YTE0ZDk1OGI4MDRjN2YyJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.WmrkOCiTafj0QyTmyxjL1cyLML15lcGE_XQuN2gwS4o)

## **Guia de armado**
En esta seccion se encontraran con un paso a paso de nuestro proceso  de armado, una guia sencilla y completa de nuestro proceso. Para empezar se adjunta un link del armado del chasis a disposici칩n p칰blica, el cual utilizamos como recurso para optimizar mejor el tiempo.


https://dukedoks.com/portfolio/guia-chasis-rc/

### **archivos de impresion de chasis fotos de la impresion**



## 游댢 Materiales y Componentes
Lista detallada de los componentes utilizados:
- **Chasis de referencias de modelado 3D**
- **Motor DC 9V kit ultimate 2.0**
- **Servo Motor Futaba S3003 08-sd-025**
- **Arduino Mega 2560**
- **Bater칤a de litio 18650 (3 UND)**
- **Puente H L298N**
- **Sensor de ultrasonido de distancia Arduino HC-SR04 (3 UND)**
- **Controlador de velocidad PWM motores DC 4.5V-35V 5A 90W**
-**Sensor de color TCS3200**

**Servo motor Rev robotics REV-41-1097**

[![servomotor ](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRCsksBOFdDB5BY8tKZa6eUbbB8zCaAIml6zw&s "servomotor ")](http://https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRCsksBOFdDB5BY8tKZa6eUbbB8zCaAIml6zw&s "servomotor ")

Descripci칩n: Servo est치ndar de 180춿 usado en rob칩tica y modelismo, con engranajes de nylon 214.

Ventajas:

1. Precisi칩n: Control angular exacto mediante se침ales PWM 14.

2. Costo bajo: Opci칩n econ칩mica para proyectos b치sicos 10.

3. Compatibilidad: Funciona con Arduino (ejemplo: control de brazos rob칩ticos) 10.

Desventajas:

 1. Torque limitado: 3.2 kg/cm a 4.8V (insuficiente para cargas pesadas) 2.

2. Fragilidad: Engranajes de nylon propensos a desgaste 14.

3. Voltaje cr칤tico: Requiere regulaci칩n precisa (recomendado 6V con UBEC)

**Arduino Mega 2560**

![descarga](https://github.com/user-attachments/assets/63b1213b-3a6c-4e2e-802f-76436bbadba5)

El Arduino Mega 2560 es una placa de desarrollo basada en el microcontrolador ATmega2560, dise침ada para proyectos que requieren m치s pines de E/S y memoria que modelos como el Arduino Uno. Es ampliamente utilizado en rob칩tica, automatizaci칩n y sistemas de control complejos.

Ventajas:

1. M칰ltiples I/O: 54 pines digitales y 16 anal칩gicos .

2. Compatibilidad: Soporta librer칤as para sensores (TCS3200, HC-SR04).

3. Comunidad amplia: Documentaci칩n extensa y ejemplos de c칩digo.

Desventajas:

1. Consumo de energ칤a: Alto vs. alternativas como ESP32.

2. Limitaci칩n de RAM: 8 KB insuficiente para procesamiento de im치genes complejas .

3. Velocidad: Procesador de 16 MHz (lento para tareas avanzadas)

**sensor der color TCS3200**

![sensor de color ](https://github.com/user-attachments/assets/ad0d0900-5da0-4351-b7b1-c4a1550e4126)

Ventajas:

1. Simpleza: Interfaz digital directa con microcontroladores 15.

2. Bajo costo: Ideal para proyectos educativos 11.

3. Configurable: Filtros RGB seleccionables por software 15.

Desventajas:

1. Sin filtro IR: Sensible a interferencias lum칤nicas 11.

2. Precisi칩n limitada: Error del 0.2% a 50 kHz 15.

3. Calibraci칩n manual: Requiere ajuste de umbrales para colores similares

**Bater칤as De Litio 18650 3.7V a 7800mA**

[![](https://http2.mlstatic.com/D_NQ_NP_881915-MLV71037692218_082023-O.webp)](http://https://http2.mlstatic.com/D_NQ_NP_881915-MLV71037692218_082023-O.webp)

**Puente H L298N**

![Sin t칤tulopuente h rojo](https://github.com/user-attachments/assets/c998e194-728f-4ca4-acd2-dbf268346189)

 **Sensor de ultrasonido de distancia Arduino HC-SR04**

![ultrasinico](https://github.com/user-attachments/assets/902c8c8b-0308-4dfd-9ffe-1c58e8a6bf10)
 
**Switches** 

[![suiche](https://sumador.com/cdn/shop/products/Suichetipobalancinde2pines2.jpg?v=1588622314 "suiche")](http://https://sumador.com/cdn/shop/products/Suichetipobalancinde2pines2.jpg?v=1588622314 "suiche")

**motor motor Makeblock 9VDC de 185 RPM**

![motor makeblock 9v](https://github.com/user-attachments/assets/8a9cdd8b-57d4-416b-b355-9b4c4810f2ba)

### **Descripcion**

El motor Makeblock 9VDC de 185 RPM es el motor m치s com칰nmente utilizado en la plataforma Makeblock o proyectos de robotica en general. Est치 impulsado por corriente continua y es la opci칩n ideal para que las cosas se muevan en todo tipo de proyectos.

### Ventajas:

1. Alto torque: Ideales para cargas medias gracias a su caja reductora (ejemplo: 185 RPM para modelos de 9V) 

2. Compatibilidad: Integrados con placas como MegaPi (basada en Arduino Mega 2560) 

3. Durabilidad: Piezas de aluminio anodizado en el kit Ultimate 2.0 9.

#### Desventajas:

1. Consumo energ칠tico: Requieren bater칤as de 9V (6xAA) o fuente externa 13.

2. Control complejo: Necesitan drivers como el L298N para PWM 9.

3. Ruido: Los engranajes pueden generar sonido en cargas altas 

## 游댣 Instalaci칩n y Montaje
Pasos de montaje mec치nico y el칠ctrico de los compo
nentes:

Diagrama de conexiones del sistema el칠ctrico.

![circuit_image](https://github.com/user-attachments/assets/2e3a6b02-0ed8-4931-bf9c-d51e61286a32)

Para el diagrama de coneccion que se uso cirkit desirgner para poder realiza una coneccion visual de donde van los pines y como va a ir cableado todo el sistema electrico y como se compone a la hora de armar 
**Partes mec치nicas de conexi칩n a las ruedas**


Bajo un concepto mec치nico manejado con pi침ones que se conectan al motor y del motor al eje principal para tener as칤 la transferencia de potencia directo a las ruedas, este es el montaje de la parte trasera de motor con el eje principal y el chasis.

[![motor ](https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-0-1536x864.jpg "motor ")](http://https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-0-1536x864.jpg "motor ")

[![](https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-1-1536x864.jpg)](http://https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-1-1536x864.jpg)

[![](https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-2-1536x864.jpg)](http://https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_02-2-1536x864.jpg)
 


**Direcci칩n delantera**
En la parte delantera se utilizo un sistema sensillo con un servomotor conectado a una barra de direcci칩n como puente a las ruedas.

[![](https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_04B-1-1536x864.jpg)](http://https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_04B-1-1536x864.jpg)

[![](https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_04B-2-1536x864.jpg)](http://https://dukedoks.com/wp-content/uploads/2024/05/Instrucciones_01_DKS-Basic_04B-2-1536x864.jpg)



5. Pruebas finales del funcionamiento del carrito RC
   
Codigo en Arduino IDE (codigo absuelto a cambios)

###Code Blocks (multi-language) & highlighting

####Inline code
#include <Servo.h>
#include <math.h> // Para la funci칩n cos() y radians()

// --- Pines de Hardware ---
#define SW_ARRANQUE 2     // Pin para el bot칩n de arranque (con pull-up interno)
#define ENA 3             // Pin PWM para el control de velocidad del motor (Debe ser un pin PWM, ej. 3, 5, 6, 9, 10, 11 en Arduino UNO)
#define IN1 4             // Pin de control de direcci칩n del motor 1
#define IN2 5             // Pin de control de direcci칩n del motor 2
#define PIN_SERVO 6       // Pin para el servo de direcci칩n
#define TRIG_FRONTAL 7    // Pin TRIG del sensor ultras칩nico frontal
#define ECHO_FRONTAL 8    // Pin ECHO del sensor ultras칩nico frontal
#define TRIG_DERECHO 9    // Pin TRIG del sensor ultras칩nico derecho
#define ECHO_DERECHO 10   // Pin ECHO del sensor ultras칩nico derecho
#define TRIG_IZQUIERDO 11 // Pin TRIG del sensor ultras칩nico izquierdo
#define ECHO_IZQUIERDO 12 // Pin ECHO del sensor ultras칩nico izquierdo

// --- Par치metros de Calibraci칩n y Comportamiento ---
#define POS_CENTRO 94      // 츼ngulo del servo para ir recto (ajustar si es necesario)
#define ANGULO_MAX_GIRO 40 // M치ximo 치ngulo de giro para el servo (e.g., 38 grados a cada lado del centro)

#define DISTANCIA_PARADA_FRONTA 35 // Distancia en cm para detenerse frente a un muro (al inicio y en cualquier obst치culo)
#define DISTANCIA_SEGURA 200       // Distancia en cm a partir de la cual la velocidad comienza a reducirse (para recta)
#define DISTANCIA_DESEADA_PARED_FIJA 30 // Distancia deseada al muro exterior fijo para el control PID (en cm)
#define UMBRAL_DETECCION_ESQUINA 100 // Distancia en cm que indica una 'apertura' en el sensor lateral para detectar esquina
#define UMBRAL_RECTA_SIMILARIDAD 5.0 // Umbral en cm para considerar que las paredes laterales son paralelas (fin de giro)
#define MARGEN_GIRO_DECISION 10.0 // Margen en cm para decidir la direcci칩n de giro (si la diferencia es menor, puede que no sea una esquina clara)
#define UMBRAL_SALIDA_GIRO_FRONTAL 60 // Nueva: Distancia frontal para considerar que el robot ha salido de la esquina y puede enderezarse.

// --- Constantes PID para control de direcci칩n ---
#define KP 0.80  // Ganancia Proporcional (ajustar)
#define KI 0.01 // Ganancia Integral (ajustar)
#define KD 0.01  // Ganancia Derivativa (ajustar)

// --- Par치metros de Velocidad ---
#define VELOCIDAD_MAXIMA 200 // Velocidad m치xima del motor (0-255 PWM)
#define VELOCIDAD_MINIMA 70  // Velocidad m칤nima del motor para movimiento
#define VELOCIDAD_GIRO 100   // Velocidad del motor al girar en una esquina
#define VELOCIDAD_REVERSA 80 // Velocidad para retroceder (nueva constante)

// --- Offset del sensor lateral (IMPORTANTE: CALIBRAR ESTE VALOR) ---
// Esta es la distancia desde el sensor lateral hasta el eje de direcci칩n del robot
// o el punto de pivote para la correcci칩n trigonom칠trica.
// Mide esta distancia en tu robot y aj칰stala.
#define SENSOR_LATERAL_OFFSET_CM 10.0 // Valor de ejemplo, 춰AJUSTAR!

// --- Configuraci칩n del Filtro de Promedio M칩vil ---
#define FILTER_SIZE 5 // N칰mero de muestras para el promedio m칩vil (ajustar)

// --- Variables Globales para el Filtro de Promedio M칩vil ---
float frontal_readings[FILTER_SIZE];
float derecha_readings[FILTER_SIZE];
float izquierda_readings[FILTER_SIZE];

int frontal_index = 0;
int derecha_index = 0;
int izquierda_index = 0;

// --- Variables Globales del Robot ---
Servo miServo; // Objeto servo

// Lecturas de los sensores ultras칩nicos (ya filtradas)
float frontal_dist;
float derecha_dist;
float izquierda_dist;

// Almacena el 치ngulo actual del servo para correcci칩n trigonom칠trica
int currentSteeringAngle = POS_CENTRO; 

// Variables de estado del robot
bool detenerCompletamente = false;
bool iniciado = false; // Bandera para saber si el robot ha iniciado el desaf칤o
bool enFaseDeGiro = false; // Indica si el robot est치 actualmente ejecutando un giro de esquina

// Variables para el control de vueltas
int seccionesEsquinaPasadas = 0;
const int MAX_SECCIONES_ESQUINA = 12; // 3 vueltas * 4 esquinas/vuelta = 12 secciones de esquina

// Variable para la direcci칩n del desaf칤o (CLO = Clockwise, CCW = Counter-Clockwise)
// Esta variable sigue siendo necesaria para el PID en las rectas (muro fijo externo)
enum DireccionDesafio { DESCONOCIDA, CLOCKWISE, COUNTER_CLOCKWISE };
DireccionDesafio direccionActual = DESCONOCIDA;

// Variables PID
float errorAnterior = 0;
float sumaErrores = 0;
unsigned long tiempoAnteriorPID = 0;

// --- Prototipos de Funciones ---
float leerUltrasonico(uint8_t trigPin, uint8_t echoPin, float* readings_buffer, int* buffer_index);
float getCorrectedLateralDistance(float raw_distance, int servo_angle_val, float sensor_offset_cm);
void motorDelante(int velocidad);
void motorAtras(int velocidad);
void motorParar();
void setSteeringAngle(int angle);
void avanzarHastaMuroInicial();
void determinarDireccionDesafio();
void controlPID();
void detectarYContarEsquina();
void manejarEsquina();
void ajustarVelocidadEnRecta();

// --- Configuraci칩n Inicial ---
void setup() {
  // Configuraci칩n de pines de motor
  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  motorParar(); // Asegurarse de que el motor est칠 parado al inicio

  // Configuraci칩n de pines de sensores ultras칩nicos
  pinMode(TRIG_FRONTAL, OUTPUT);
  pinMode(ECHO_FRONTAL, INPUT);
  pinMode(TRIG_DERECHO, OUTPUT);
  pinMode(ECHO_DERECHO, INPUT);
  pinMode(TRIG_IZQUIERDO, OUTPUT);
  pinMode(ECHO_IZQUIERDO, INPUT);

  pinMode(13, OUTPUT); // Pin 13 para LED de depuraci칩n

  // Configuraci칩n del bot칩n de arranque con pull-up interno
  pinMode(SW_ARRANQUE, INPUT_PULLUP);

  // Adjuntar el servo
  miServo.attach(PIN_SERVO);
  setSteeringAngle(POS_CENTRO); // Poner las ruedas rectas al inicio
  delay(100); // Peque침a pausa para que el servo se estabilice

  // Iniciar comunicaci칩n serial para depuraci칩n
  Serial.begin(9600);
  Serial.println("Sistema iniciado. Esperando boton de arranque...");
  digitalWrite(13, HIGH); // LED encendido indicando espera

  // Inicializar buffers del filtro de promedio m칩vil con un valor por defecto
  for (int i = 0; i < FILTER_SIZE; i++) {
    frontal_readings[i] = 300.0;
    derecha_readings[i] = 400.0;
    izquierda_readings[i] = 400.0;
  }
}

// --- Bucle Principal ---
void loop() {
  // Leer el estado del bot칩n de arranque
  if (digitalRead(SW_ARRANQUE) == LOW) { // Si el bot칩n est치 presionado (LOW por pull-up)
    if (!iniciado) {
      Serial.println("Boton de arranque presionado. Iniciando desafio.");
      delay(50); // Antirebote
      digitalWrite(13, LOW); // LED apagado indicando inicio
      iniciado = true; // El robot ha iniciado
      detenerCompletamente = false; // Reiniciar estado de detenci칩n
    }
  }

  if (iniciado && !detenerCompletamente) {
    // 1. Leer sensores (ahora con filtro de promedio m칩vil)
    frontal_dist = leerUltrasonico(TRIG_FRONTAL, ECHO_FRONTAL, frontal_readings, &frontal_index);
    derecha_dist = leerUltrasonico(TRIG_DERECHO, ECHO_DERECHO, derecha_readings, &derecha_index);
    izquierda_dist = leerUltrasonico(TRIG_IZQUIERDO, ECHO_IZQUIERDO, izquierda_readings, &izquierda_index);

    // Imprimir lecturas para depuraci칩n en Serial Monitor
    Serial.print("F:"); Serial.print(frontal_dist);
    Serial.print(" D:"); Serial.print(derecha_dist);
    Serial.print(" I:"); Serial.println(izquierda_dist);

    // --- L칩gica del Desaf칤o ---

    // Paso 1: Avanzar hasta el muro inicial y determinar la direcci칩n si a칰n no se ha hecho
    if (direccionActual == DESCONOCIDA) {
      Serial.println("Avanzando hacia el muro inicial y centrando...");
      avanzarHastaMuroInicial(); // Avanza, se detiene y usa PID para centrarse
      
      // Una vez detenido frente al muro, determina la direcci칩n
      determinarDireccionDesafio();
      
      // Si la direcci칩n no se pudo determinar, el robot retrocede y el loop intentar치 de nuevo.
      if (direccionActual == DESCONOCIDA) {
        Serial.println("Direccion no determinada. Retrocediendo para reintentar.");
        motorAtras(VELOCIDAD_REVERSA); // Retroceder
        delay(500); // Tiempo para retroceder
        motorParar();
        setSteeringAngle(POS_CENTRO); // Enderezar ruedas
        delay(200);
        // El loop() volver치 a ejecutar el if(direccionActual == DESCONOCIDA)
        // y reintentar치 avanzarHastaMuroInicial y determinarDireccionDesafio.
      } else {
        Serial.print("Direccion del desafio determinada: ");
        if (direccionActual == CLOCKWISE) {
          Serial.println("CLOCKWISE");
        } else if (direccionActual == COUNTER_CLOCKWISE) {
          Serial.println("COUNTER_CLOCKWISE");
        }
        Serial.println("Listo para seguir el carril.");
        delay(20); // Peque침a pausa para ver el mensaje
      }
    } else {
      // Si la direcci칩n ya est치 determinada, el robot est치 en el ciclo de seguimiento de carril y vueltas
      if (!enFaseDeGiro) { // Solo ajustar velocidad y PID si no est치 en una fase de giro activa
        ajustarVelocidadEnRecta(); // Ajustar velocidad basada en la distancia frontal (generalizado)
        controlPID();              // Mantenerse en el centro del carril
      }
      detectarYContarEsquina();  // Detectar y contar esquinas (llama a manejarEsquina si detecta)
    }

    // Comprobar si se han completado las 3 vueltas
    if (seccionesEsquinaPasadas >= MAX_SECCIONES_ESQUINA) {
      Serial.println("3 vueltas completadas! Deteniendo el robot.");
      motorParar();
      detenerCompletamente = true; // Detener completamente el robot
      iniciado = false; // Resetear el estado para que no vuelva a entrar en el bucle principal
      digitalWrite(13, HIGH); // Encender LED para indicar fin del desaf칤o
    }
  } else if (detenerCompletamente) {
    motorParar(); // Asegurarse de que el motor est칠 parado
    setSteeringAngle(POS_CENTRO); // Ruedas rectas al finalizar
    delay(10); // Peque침a pausa para no saturar el serial
  }
}

// --- Implementaci칩n de Funciones Auxiliares ---

/**
 * @brief Lee la distancia de un sensor ultras칩nico y aplica un filtro de promedio m칩vil.
 * @param trigPin El pin TRIG del sensor.
 * @param echoPin El pin ECHO del sensor.
 * @param readings_buffer Puntero al array (buffer) de lecturas para el filtro.
 * @param buffer_index Puntero al 칤ndice actual en el buffer.
 * @return La distancia filtrada en cent칤metros.
 */
float leerUltrasonico(uint8_t trigPin, uint8_t echoPin, float* readings_buffer, int* buffer_index) {
  // Realizar una lectura cruda del sensor
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duracion = pulseIn(echoPin, HIGH);
  float raw_distanceCm = duracion * 0.034 / 2;

  // Filtrado simple de valores extremos antes de a침adir al buffer
  if (raw_distanceCm == 0 || raw_distanceCm > 400 || raw_distanceCm < 2) { 
    raw_distanceCm = 400.0; // Asignar un valor grande para lecturas fuera de rango
  }

  // A침adir la nueva lectura al buffer circular
  readings_buffer[*buffer_index] = raw_distanceCm;
  *buffer_index = (*buffer_index + 1) % FILTER_SIZE; // Mover al siguiente 칤ndice, envolviendo al inicio

  // Calcular el promedio de las lecturas en el buffer
  float sum = 0;
  for (int i = 0; i < FILTER_SIZE; i++) {
    sum += readings_buffer[i];
  }
  return sum / FILTER_SIZE;
}

/**
 * @brief Corrige la distancia le칤da por un sensor lateral bas치ndose en el 치ngulo de direcci칩n del servo.
 * Esto compensa cuando el sensor no est치 perpendicular a la pared debido a un giro.
 * @param raw_distance La lectura de distancia cruda del sensor lateral.
 * @param servo_angle_val El 치ngulo actual del servo de direcci칩n (currentSteeringAngle).
 * @param sensor_offset_cm Distancia del sensor al eje de giro del veh칤culo (longitudinal).
 * @return La distancia estimada corregida a la pared.
 */
float getCorrectedLateralDistance(float raw_distance, int servo_angle_val, float sensor_offset_cm) {
  // Calcular el 치ngulo de desviaci칩n del servo respecto al centro.
  float angle_deviation_degrees = (float)servo_angle_val - POS_CENTRO; // Puede ser positivo o negativo
  
  // Convertir grados a radianes para la funci칩n cos() y sin()
  float angle_deviation_radians = radians(angle_deviation_degrees);
  
  // Si raw_distance es muy grande (no hay pared), la correcci칩n no tiene sentido.
  if (raw_distance > UMBRAL_DETECCION_ESQUINA) { 
      return raw_distance;
  }

  // F칩rmula trigonom칠trica para la distancia perpendicular real a la pared.
  // Se asume que el sensor est치 montado de forma que su eje de medici칩n es perpendicular al robot cuando el servo est치 en POS_CENTRO.
  // Cuando el servo gira, el sensor se inclina. La distancia perpendicular real a la pared es raw_distance * cos(치ngulo_desviaci칩n).
  // El 'sensor_offset_cm' es la distancia longitudinal del sensor al eje de giro.
  // Si el sensor est치 delante del eje de giro y gira hacia la pared, la lectura es menor de lo que deber칤a ser perpendicular.
  // Si el sensor est치 detr치s del eje de giro y gira hacia la pared, la lectura es mayor de lo que deber칤a ser perpendicular.
  // Una aproximaci칩n podr칤a ser: corrected_dist = raw_distance * cos(angle_deviation_radians) + sensor_offset_cm * sin(angle_deviation_radians);
  // Sin embargo, esto puede introducir m치s ruido si el offset no se calibra perfectamente.
  // Para este desaf칤o, raw_distance * cos(angle_deviation_radians) es un buen punto de partida.

  return raw_distance * cos(angle_deviation_radians); // Simplificado a la proyecci칩n coseno
}


// Funci칩n para mover el motor hacia adelante
void motorDelante(int velocidad) {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  analogWrite(ENA, constrain(velocidad, 0, 255)); // Limitar velocidad entre 0 y 255
}

// Funci칩n para mover el motor hacia atr치s (no se usa en este desaf칤o, pero 칰til)
void motorAtras(int velocidad) {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  analogWrite(ENA, constrain(velocidad, 0, 255));
}

// Funci칩n para detener el motor
void motorParar() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  analogWrite(ENA, 0); // Detener el motor
}

// Funci칩n para establecer el 치ngulo del servo de direcci칩n
void setSteeringAngle(int angle) {
  // Limitar el 치ngulo para evitar que el servo exceda sus l칤mites mec치nicos
  currentSteeringAngle = constrain(angle, POS_CENTRO - ANGULO_MAX_GIRO, POS_CENTRO + ANGULO_MAX_GIRO); 
  miServo.write(currentSteeringAngle);
}

// --- Funciones de L칩gica del Desaf칤o ---

// El robot avanza hasta que el sensor frontal detecta un muro a DISTANCIA_PARADA_FRONTA
// Y utiliza PID para mantenerse centrado en el carril.
void avanzarHastaMuroInicial() {
  float velActual;

  while (frontal_dist > DISTANCIA_PARADA_FRONTA) { // Se detiene a DISTANCIA_PARADA_FRONTA
    frontal_dist = leerUltrasonico(TRIG_FRONTAL, ECHO_FRONTAL, frontal_readings, &frontal_index);
    derecha_dist = leerUltrasonico(TRIG_DERECHO, ECHO_DERECHO, derecha_readings, &derecha_index);
    izquierda_dist = leerUltrasonico(TRIG_IZQUIERDO, ECHO_IZQUIERDO, izquierda_readings, &izquierda_index);

    Serial.print("Avz. Inicial: F:"); Serial.print(frontal_dist);
    Serial.print(" D:"); Serial.print(derecha_dist);
    Serial.print(" I:"); Serial.println(izquierda_dist);

    // Ajustar velocidad: m치s r치pido cuando est치 lejos, m치s lento cuando est치 cerca
    velActual = map(frontal_dist, DISTANCIA_PARADA_FRONTA, DISTANCIA_SEGURA, VELOCIDAD_MINIMA, VELOCIDAD_MAXIMA);
    velActual = constrain(velActual, VELOCIDAD_MINIMA, VELOCIDAD_MAXIMA);
    motorDelante(velActual);
    
    // Aplicar PID para centrarse en el carril, incluso antes de conocer la direcci칩n
    // En este estado, el PID buscar치 igualar las distancias izquierda y derecha.
    controlPID(); // controlPID ahora maneja el estado DESCONOCIDA para centrado.

    delay(20); // Peque침a pausa para lecturas estables y fluidez
  }
  motorParar(); // Detener completamente al alcanzar la distancia de parada
  Serial.println("Detenido frente al muro inicial.");
  delay(200); // Pausa para estabilizar despu칠s de la parada
}

// Determina la direcci칩n del desaf칤o (Clockwise o Counter-Clockwise)
// Asume que al detenerse frente al muro inicial, un lado estar치 m치s "abierto" que el otro.
void determinarDireccionDesafio() {
  // Despu칠s de detenerse frente al muro, leer de nuevo los sensores laterales
  derecha_dist = leerUltrasonico(TRIG_DERECHO, ECHO_DERECHO, derecha_readings, &derecha_index);
  izquierda_dist = leerUltrasonico(TRIG_IZQUIERDO, ECHO_IZQUIERDO, izquierda_readings, &izquierda_index);

  Serial.print("Determinado direccion: Derecha: "); Serial.print(derecha_dist);
  Serial.print(", Izquierda: "); Serial.println(izquierda_dist);
  delay(200);

  float diferencia = abs(derecha_dist - izquierda_dist);
  float margen_error_ultrasonico = 10.0; // Margen para la precisi칩n del sensor

  if (diferencia > margen_error_ultrasonico) {
    if (derecha_dist > izquierda_dist) {
      direccionActual = CLOCKWISE;
      Serial.println("Direccion: CLOCKWISE");
    } else {
      direccionActual = COUNTER_CLOCKWISE;
      Serial.println("Direccion: COUNTER_CLOCKWISE");
    }
  } else {
    Serial.println("No se pudo determinar la direccion del desafio, retrocediendo para reintentar...");
    digitalWrite(13, HIGH); // Encender led para indicar que no se determin칩 la direcci칩n del desaf칤o
    direccionActual = DESCONOCIDA; // Resetear la direcci칩n para forzar un reintento en el loop principal
  }
}

// Control PID para mantener el robot en el centro del carril
void controlPID() {
  float error = 0;
  // Pasar SENSOR_LATERAL_OFFSET_CM como tercer argumento
  float corrected_izquierda_dist = getCorrectedLateralDistance(izquierda_dist, currentSteeringAngle, SENSOR_LATERAL_OFFSET_CM);
  float corrected_derecha_dist = getCorrectedLateralDistance(derecha_dist, currentSteeringAngle, SENSOR_LATERAL_OFFSET_CM);

  if (direccionActual == DESCONOCIDA) {
    // Si la direcci칩n es desconocida (fase inicial), intentar centrarse entre ambas paredes.
    // Error positivo significa que la izquierda est치 m치s lejos que la derecha, el robot est치 m치s cerca de la pared derecha, necesita girar a la izquierda.
    // Error negativo significa que la izquierda est치 m치s cerca que la derecha, el robot est치 m치s cerca de la pared izquierda, necesita girar a la derecha.
    error = corrected_izquierda_dist - corrected_derecha_dist;
  } else if (direccionActual == CLOCKWISE) {
    // Si va en sentido horario (CW), el muro fijo (externo) est치 a la izquierda.
    // El PID controla la distancia a este muro.
    error = corrected_izquierda_dist - DISTANCIA_DESEADA_PARED_FIJA;
  } else if (direccionActual == COUNTER_CLOCKWISE) {
    // Si va en sentido anti-horario (CCW), el muro fijo (externo) est치 a la derecha.
    // El PID controla la distancia a este muro.
    error = corrected_derecha_dist - DISTANCIA_DESEADA_PARED_FIJA;
  }

  unsigned long tiempoActualPID = millis();
  float deltaTime = (tiempoActualPID - tiempoAnteriorPID) / 1000.0; // Convertir a segundos
  if (deltaTime == 0) deltaTime = 0.001; // Evitar division por cero
  tiempoAnteriorPID = tiempoActualPID;

  // Componente Proporcional
  float p_term = KP * error;

  // Componente Integral (anti-windup simple)
  sumaErrores += error * deltaTime;
  // Limitar la suma de errores para evitar saturaci칩n del integrador
  if (sumaErrores > 200) sumaErrores = 200;
  if (sumaErrores < -200) sumaErrores = -200;
  float i_term = KI * sumaErrores;

  // Componente Derivativo
  float d_term = KD * ((error - errorAnterior) / deltaTime);
  errorAnterior = error;

  // Calcular la correcci칩n total del PID
  float correccion = p_term + i_term + d_term;

  // Ajustar el 치ngulo del servo
  int anguloServo = POS_CENTRO;

  // La l칩gica de ajuste del 치ngulo del servo depende de la direcci칩n del desaf칤o
  // y de si estamos en la fase DESCONOCIDA.
  if (direccionActual == CLOCKWISE || direccionActual == DESCONOCIDA) {
    // Para CW (muro fijo a la izquierda) o DESCONOCIDA (centrado):
    // Si error > 0 (lejos de pared izquierda en CW, o m치s cerca de derecha en DESCONOCIDA), necesita girar a la izquierda (치ngulo < POS_CENTRO)
    // Si error < 0 (cerca de pared izquierda en CW, o m치s cerca de izquierda en DESCONOCIDA), necesita girar a la derecha (치ngulo > POS_CENTRO)
    anguloServo = POS_CENTRO - (int)correccion; // Invertir correcci칩n para que un error positivo gire a la izquierda
  } else if (direccionActual == COUNTER_CLOCKWISE) {
    // Para CCW (muro fijo a la derecha):
    // Si error > 0 (lejos de pared derecha), necesita girar a la derecha (치ngulo > POS_CENTRO)
    // Si error < 0 (cerca de pared derecha), necesita girar a la izquierda (치ngulo < POS_CENTRO)
    anguloServo = POS_CENTRO + (int)correccion; // Error positivo debe girar a la derecha
  }

  setSteeringAngle(anguloServo);
  Serial.print("PID Err:"); Serial.print(error);
  Serial.print(" Corr:"); Serial.print(correccion);
  Serial.print(" Ang:"); Serial.println(anguloServo);
}

// Detecta el paso por una secci칩n de esquina y actualiza el contador de vueltas.
void detectarYContarEsquina() {
  bool esEsquinaDetectada = false;

  // Detecci칩n de esquina:
  // Se detecta una esquina si el camino frontal est치 despejado
  // Y al menos uno de los sensores laterales detecta una apertura significativa.
  if (frontal_dist > (DISTANCIA_PARADA_FRONTA + 10) && 
      (derecha_dist > UMBRAL_DETECCION_ESQUINA || izquierda_dist > UMBRAL_DETECCION_ESQUINA)) { 
    esEsquinaDetectada = true;
  }

  // L칩gica para contar la esquina solo una vez por esquina y manejar el giro
  static bool enTramoRectoPrevioEsquina = true; // Estado para evitar doble conteo y asegurar transici칩n
  
  if (esEsquinaDetectada && enTramoRectoPrevioEsquina && !enFaseDeGiro) {
    Serial.println("춰Potencial esquina detectada! Iniciando manejo de esquina...");
    enFaseDeGiro = true; // Entrar en fase de giro
    enTramoRectoPrevioEsquina = false; // Resetear para la siguiente esquina
    manejarEsquina(); // Ejecutar la l칩gica de giro
    // Despu칠s de manejar la esquina, el robot ya deber칤a estar en la siguiente recta, listo para PID.
    seccionesEsquinaPasadas++;
    Serial.print("Esquina completada. Secciones pasadas: "); Serial.println(seccionesEsquinaPasadas);
    delay(200); // Pausa para ver el mensaje
    enFaseDeGiro = false; // Salir de la fase de giro una vez que se complet칩
  } else if (!esEsquinaDetectada && !enTramoRectoPrevioEsquina && !enFaseDeGiro) {
    // Una vez que el robot ha salido de la esquina y no est치 en fase de giro
    // y los sensores ya no detectan una esquina, se considera que est치 en una recta de nuevo.
    enTramoRectoPrevioEsquina = true; 
  }
}

/**
 * @brief Maneja el giro en una esquina. El robot gira las ruedas y avanza hasta que los sensores
 * indican que ha completado la curva y ha entrado en una nueva secci칩n recta.
 */
void manejarEsquina() {
  Serial.println("Manejando esquina...");
  motorParar(); // Detener brevemente antes de iniciar el giro o ajustar el 치ngulo
  delay(50); // Peque침a pausa para estabilizar

  // --- Decidir la direcci칩n de giro basada en la mayor amplitud ---
  // Se usan las lecturas filtradas globales (frontal_dist, derecha_dist, izquierda_dist)
  // que ya se actualizan continuamente en el loop principal.
  
  int anguloDeGiro = POS_CENTRO;
  Serial.print("Decision de giro: Derecha: "); Serial.print(derecha_dist);
  Serial.print(", Izquierda: "); Serial.println(izquierda_dist);

  // Se a침ade una condici칩n para asegurar que al menos uno de los lados realmente est치 "abierto"
  // para evitar giros en falso si el robot est치 en un tramo recto pero con lecturas ruidosas.
  if (derecha_dist > UMBRAL_DETECCION_ESQUINA && izquierda_dist > UMBRAL_DETECCION_ESQUINA) {
      // Si ambos lados est치n muy abiertos, elegir el que tenga mayor amplitud.
      if (derecha_dist > izquierda_dist) {
          anguloDeGiro = POS_CENTRO + ANGULO_MAX_GIRO; // Girar a la derecha
          Serial.println("Girando ruedas a la derecha (ambos abiertos, derecha mas).");
      } else {
          anguloDeGiro = POS_CENTRO - ANGULO_MAX_GIRO; // Girar a la izquierda
          Serial.println("Girando ruedas a la izquierda (ambos abiertos, izquierda mas).");
      }
  } else if (derecha_dist > UMBRAL_DETECCION_ESQUINA) {
      anguloDeGiro = POS_CENTRO + ANGULO_MAX_GIRO + 10; // Girar a la derecha
      Serial.println("Girando ruedas a la derecha (derecha abierta).");
  } else if (izquierda_dist > UMBRAL_DETECCION_ESQUINA) {
      anguloDeGiro = POS_CENTRO - ANGULO_MAX_GIRO; // Girar a la izquierda
      Serial.println("Girando ruedas a la izquierda (izquierda abierta).");
  } else {
      // Si ninguna apertura clara se detecta, esto es un caso inesperado en una esquina.
      // Como fallback, se puede intentar un giro predefinido o detenerse.
      // Aqu칤, usaremos la direcci칩n general del desaf칤o como un 칰ltimo recurso.
      Serial.println("Ninguna apertura clara detectada en esquina. Usando direccion general.");
      if (direccionActual == CLOCKWISE) {
          anguloDeGiro = POS_CENTRO + ANGULO_MAX_GIRO;
      } else if (direccionActual == COUNTER_CLOCKWISE) {
          anguloDeGiro = POS_CENTRO - ANGULO_MAX_GIRO;
      } else {
          // Si ni siquiera la direcci칩n general est치 definida, girar a la derecha por defecto.
          anguloDeGiro = POS_CENTRO + ANGULO_MAX_GIRO + 10;
          Serial.println("Direccion general desconocida, girando a la derecha por defecto.");
      }
  }

  setSteeringAngle(anguloDeGiro);
  delay(100); // Dar tiempo al servo para alcanzar la posici칩n

  motorDelante(VELOCIDAD_GIRO); // Moverse a velocidad reducida durante el giro

  // 2. Esperar a que el robot complete el giro bas치ndose en las lecturas de los sensores
  // El giro termina cuando:
  // a) El sensor frontal no detecta obst치culos cercanos (el camino est치 despejado)
  // b) Ambos sensores laterales (corregidos) detectan paredes a una distancia similar y razonable,
  //    indicando que el robot ha entrado en una nueva secci칩n recta.

  unsigned long tiempoInicioGiro = millis();
  const long TIMEOUT_GIRO = 5500; // Aumentado a 5.5 segundos para dar m치s tiempo al giro

  while (millis() - tiempoInicioGiro < TIMEOUT_GIRO) {
    frontal_dist = leerUltrasonico(TRIG_FRONTAL, ECHO_FRONTAL, frontal_readings, &frontal_index);
    derecha_dist = leerUltrasonico(TRIG_DERECHO, ECHO_DERECHO, derecha_readings, &derecha_index);
    izquierda_dist = leerUltrasonico(TRIG_IZQUIERDO, ECHO_IZQUIERDO, izquierda_readings, &izquierda_index);

    // Pasar SENSOR_LATERAL_OFFSET_CM como tercer argumento
    float corrected_derecha = getCorrectedLateralDistance(derecha_dist, currentSteeringAngle, SENSOR_LATERAL_OFFSET_CM);
    float corrected_izquierda = getCorrectedLateralDistance(izquierda_dist, currentSteeringAngle, SENSOR_LATERAL_OFFSET_CM);

    Serial.print("Girando... F:"); Serial.print(frontal_dist);
    Serial.print(" CD:"); Serial.print(corrected_derecha);
    Serial.print(" CI:"); Serial.println(corrected_izquierda);

    // --- Depuraci칩n de las condiciones de salida del giro ---
    Serial.print("Condiciones de salida: ");
    Serial.print("F_OK: "); Serial.print(frontal_dist > UMBRAL_SALIDA_GIRO_FRONTAL);
    Serial.print(", CD_OK: "); Serial.print(corrected_derecha < UMBRAL_DETECCION_ESQUINA);
    Serial.print(", CI_OK: "); Serial.print(corrected_izquierda < UMBRAL_DETECCION_ESQUINA);
    Serial.print(", SIM_OK: "); Serial.println(abs(corrected_derecha - corrected_izquierda) < UMBRAL_RECTA_SIMILARIDAD);
    // --- Fin de Depuraci칩n ---

    // Condici칩n de salida del giro:
    // 1. Camino frontal despejado (ya no est치 'pegado' al muro de la esquina)
    // 2. Ambos lados detectan paredes (no apertura)
    // 3. Las distancias laterales corregidas son "similares" (ha enderezado y est치 en una recta)
    if (frontal_dist > UMBRAL_SALIDA_GIRO_FRONTAL &&
        corrected_derecha < UMBRAL_DETECCION_ESQUINA &&
        corrected_izquierda < UMBRAL_DETECCION_ESQUINA &&
        abs(corrected_derecha - corrected_izquierda) < UMBRAL_RECTA_SIMILARIDAD) {
      Serial.println("Fin del giro detectado: En nueva recta.");
      break; // Salir del bucle de giro
    }
    delay(80); // Peque침a pausa
  }
  
  if (millis() - tiempoInicioGiro >= TIMEOUT_GIRO) {
    Serial.println("Timeout en el giro. Puede que no haya detectado el fin de la esquina correctamente.");
    digitalWrite(13, HIGH); // Encender LED si hay timeout en el giro
  }

  motorParar(); // Detener al final del giro para asegurar la estabilidad
  setSteeringAngle(POS_CENTRO); // Volver las ruedas rectas
  delay(50); // Peque침a pausa antes de continuar
}

/**
 * @brief Ajusta la velocidad del robot en los tramos rectos.
 * La velocidad es proporcional a la distancia del muro frontal, disminuyendo a medida que se acerca.
 */
void ajustarVelocidadEnRecta() {
  if (frontal_dist > DISTANCIA_PARADA_FRONTA) {
    int velocidadAdaptativa = map(frontal_dist, DISTANCIA_PARADA_FRONTA, DISTANCIA_SEGURA, VELOCIDAD_MINIMA, VELOCIDAD_MAXIMA);
    velocidadAdaptativa = constrain(velocidadAdaptativa, VELOCIDAD_MINIMA, VELOCIDAD_MAXIMA);
    motorDelante(velocidadAdaptativa);
    Serial.print("Velocidad adaptativa en recta: "); Serial.println(velocidadAdaptativa);
  } else {
    motorParar(); 
    Serial.println("Muro frontal detectado, deteniendo en ajustarVelocidadEnRecta.");
    delay(100); // Peque침a pausa para ver el mensaje de detenci칩n
  }
}

###End
